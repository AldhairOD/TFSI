# -*- coding: utf-8 -*-
"""KMeansAppTF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j0f1JBkfb6ypG8eoMBvEsnUV9Yw2YtjT

Imports para el proyecto
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.cluster import SpectralClustering
from sklearn.mixture import GaussianMixture
from sklearn.metrics import silhouette_score, homogeneity_score, completeness_score, v_measure_score, adjusted_rand_score
import matplotlib.pyplot as plt
import seaborn as sns

"""Lectura de archivos CSV"""

# Leer los archivos CSV
data_path = '/content/drive/MyDrive/2020-Gasto-COVID-19.csv'
dic_path = '/content/drive/MyDrive/Gasto_COVID_19_Diccionario.csv'

# Leer el conjunto de datos principal
data = pd.read_csv(data_path, encoding='latin1')

# Leer el diccionario de datos
diccionario = pd.read_csv(dic_path, encoding='latin1')

"""Inspeccionamiento de datos y diccionario de datos"""

# Mostrar las primeras filas de los datos
print("Datos principales:")
print(data.head())

print("\nDiccionario de datos:")
print(diccionario.head())

"""Filtrado de datos"""

# Filtrar columnas relevantes
data_filtered = data[['MONTO_CERTIFICADO', 'MONTO_DEVENGADO']]

# Convertir a numérico y manejar valores faltantes
data_filtered['MONTO_CERTIFICADO'] = pd.to_numeric(data_filtered['MONTO_CERTIFICADO'], errors='coerce')
data_filtered['MONTO_DEVENGADO'] = pd.to_numeric(data_filtered['MONTO_DEVENGADO'], errors='coerce')

# Eliminar filas con valores faltantes
data_filtered.dropna(inplace=True)

print("Datos filtrados y limpios:")
print(data_filtered.describe())

"""Aplicar K-Means"""

# Aplicar K-Means
# Determinar el número óptimo de clusters usando el método del codo
def plot_elbow_method(data, max_clusters=10):
    distortions = []
    for i in range(1, max_clusters+1):
        kmeans = KMeans(n_clusters=i, random_state=0)
        kmeans.fit(data)
        distortions.append(kmeans.inertia_)

    plt.figure(figsize=(8, 4))
    plt.plot(range(1, max_clusters+1), distortions, marker='o')
    plt.xlabel('Número de clusters')
    plt.ylabel('Distorsión')
    plt.title('Método del codo para determinar el número óptimo de clusters')
    plt.grid(True)
    plt.show()

plot_elbow_method(data_filtered)

# Elegir el número óptimo de clusters 3
kmeans = KMeans(n_clusters=3, random_state=0)
data_filtered['Cluster'] = kmeans.fit_predict(data_filtered)

print("Datos con clusters asignados:")
print(data_filtered.head())

"""Visualizacion de k-means y analisis"""

# Visualización y análisis
# Visualización de los clusters
plt.figure(figsize=(10, 6))
plt.scatter(data_filtered['MONTO_CERTIFICADO'], data_filtered['MONTO_DEVENGADO'], c=data_filtered['Cluster'], cmap='viridis')
plt.xlabel('Monto Certificado')
plt.ylabel('Monto Devengado')
plt.title('Patrones de Inversión del Gobierno durante la Pandemia (K-Means Clustering)')
plt.colorbar(label='Cluster')
plt.grid(True)
plt.show()

"""Analisis descriptivo por cluster"""

# Análisis descriptivo por cluster
cluster_analysis = data_filtered.groupby('Cluster').mean()
print("Análisis descriptivo por cluster:")
print(cluster_analysis)

"""Evaluacion de modelo"""

# Evaluación del modelo
# Métricas de evaluación sin etiquetas verdaderas
silhouette_avg = silhouette_score(data_filtered[['MONTO_CERTIFICADO', 'MONTO_DEVENGADO']], data_filtered['Cluster'])
print(f"Índice de Silueta: {silhouette_avg:.3f}")

# Para métricas que requieren etiquetas verdaderas, simulamos etiquetas verdaderas
true_labels = np.random.randint(0, 3, len(data_filtered))

# Calcular métricas que requieren etiquetas verdaderas
homogeneity = homogeneity_score(true_labels, data_filtered['Cluster'])
completeness = completeness_score(true_labels, data_filtered['Cluster'])
v_measure = v_measure_score(true_labels, data_filtered['Cluster'])

print(f"Homogeneidad: {homogeneity:.3f}")
print(f"Completeness: {completeness:.3f}")
print(f"V-Measure: {v_measure:.3f}")

# Calcular inercia
inertia = kmeans.inertia_
print(f"Inercia (Suma de Cuadrados Dentro del Cluster): {inertia:.3f}")